.. _topics-db-models:

===================
Escribiendo modelos
===================

.. module:: django.db.models

Un modelo es la única fuente definitiva de datos acerca de tus datos. Contiene
los campos esenciales y comportamientos de los datos que tú estás almacenando. Generalmente, cada
modelo <todo: maps> a una sola tabla de base de datos.

Lo basico:
    * Cada modelo es una clase Python que <todo: subclasses>
      :class:`django.db.models.Model`.
    
    * Cada atributo del modelo representa un campo de base de datos.

    * Con todo esto Django te da un automático-generado
      <todo: database-access> API; ver:ref:`topics-db-queries`.

.. vertambién::

    Una compañía a este documento es el `repositorio oficial de ejemplos de 
    modelos`_. (En la distribución fuente de Django, estos ejemplos están en el
    directorio ``tests/modeltests``.)

    .. _official repository of model examples: http://www.djangoproject.com/documentation/models/

Simple Ejemplo
==============

Este ejemplo de modelo define una ``Persona``, el cual tiene un ``first_name`` y
``last_name``::

    from django.db import models

    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

``first_name`` y ``last_name`` son campos_ del modelo. Cada campo es
especificado como un atributo de la clase, y cada atributo <todo:  maps> a una columna de la base de datos.

El modelo ``Persona`` antedicho crearía una tabla de base de datos como esta: 

.. code-block:: sql

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );

Algunas notas técnicas:

    * El nombre de la tabla, ``myapp_person``, es automáticamente derivado de
      algún modelo metadata pero puede ser renombrado. Ver :ref:`table-names` para mas
      detalles..
      
    * Un campo ``id`` es añadido automaticamente, pero este comportamiento puede ser
      re-escrito o cambiado. Ver :ref:`automatic-primary-key-fields`.
            
    * El ``CREATE TABLE`` SQL en este ejemplo es formateado usando PostgreSQL
      syntaxis, pero vale nada Django usa SQL adaptado a la base de datos
      <todo: backend> especificado en tu :ref:`archivo de configuración <topics-settings>`.

Usando modelos
==============

Una vez que hayas definido tus modelos, tú necesitas decir a Django que vas a *usar*
esos modelos. Haz esto editando tu archivo de configuración y cambiando la
:configuración:`INSTALLED_APPS` para añadir el nombre del modelo que contiene
tu ``models.py``.

Por ejemplo, si los modelos de tu aplicación vive en el modulo
``mysite.myapp.models`` (la estructura del paquete que es creado para una
aplicación por el :djadmin:`manage.py startapp <startapp>` script),
:configuración:`INSTALLED_APPS` debería leer, en parte::

    INSTALLED_APPS = (
        #...
        'mysite.myapp',
        #...
    )

Cuando tú agregas nuevos apps a :configuración:`INSTALLED_APPS`, asegurate de correr
:djadmin:`manage.py syncdb <syncdb>`.

Campos
======

La parte mas importante de un modelo -- y la única parte requerida de un modelo -- 
es la lista de los campos de la base de datos que define. Campos son especificados por 
atributos de clase. <todo: class attributes.> 

Ejemplo::

    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)

    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()

Typos de Campo
--------------

Cada campo en tu modelo debe ser una instancia del apropiado
:class:`~django.db.models.Field` clase. Django usa el tipo de clase del campo
para determinar unas pequeñas cosas:

    * El tipo de columna de la base de datos (ex. ``INTEGER``, ``VARCHAR``).

    * El widget a utilizar en la interface de administración de Django, si te importa usarlo
      (ex. ``<input type="text">``, ``<select>``).

    * Los requisitos mínimos de validación, usado en el admin de Django y en las formas
      automáticamente-generadas.

EDjango ships con docenas de <todo: built-in> tipos de campos; tu puedes encontrar la lista completa
en la :ref:`referencia modelo campo <model-field-types>`. Tu puedes escribir fácilmente 
tus propios campos si los <todo: built-in> existentes de Django no hacen el truco; ver 
:ref:`howto-custom-model-fields`.

Opciones de un Campo
--------------------

Cada campo toma cierto conjunto de argumentos de campo-específico (documentado la
:ref:`referencia modelo campo  <model-field-types>`). Por ejemplo,
:class:`~django.db.models.CharField` (y sus sub-clases) requiere un
:attr:`~django.db.models.CharField.max_length` argumento el cual especifica el tamaño
del ``VARCHAR`` campo de la base de datos usado para almacenar los datos.

También hay un conjunto de argumentos comunes disponibles para todos los tipos de campo. Todos son
opcionales. Están explicados completamente en la :ref:`referencia
<common-model-field-options>`, pero aquí está un resumen rápido de los mas usados 
frecuentemente:

    :attr:`~Field.null`
        Si ``True``, Django almacenará valores vacíos como ``NULL`` en la base de datos.
        Por defecto es ``False``.

    :attr:`~Field.blank`
        Si ``True``, el campo es permitido tener blancos. Por defecto es ``False``.

        Nota que es diferente que :attr:`~Field.null`.
        :attr:`~Field.null` es puramente relacionado con la base de datos, mientras que
        :attr:`~Field.blank` es relacionado con validación. Si un campo tiene
        :attr:`blank=True <Field.blank>`, validación en la sección admin de Django
        permitirá la entrada de un valor vacío. Si un campo tiene :attr:`blank=False
        <Field.blank>`, el campo será requerido.

    :attr:`~Field.choices`
        Un iterable (ex., una lista o tuplo) de 2-tuplos para usar como opciones para
        este campo. Si esto es dado, el admin de  Django usará como un select box
        en vez del estandard campo texto y limitará choices a las opciones
		dadas.

        Una lista de choices parece algo asi::

            YEAR_IN_SCHOOL_CHOICES = (
                ('FR', 'Freshman'),
                ('SO', 'Sophomore'),
                ('JR', 'Junior'),
                ('SR', 'Senior'),
                ('GR', 'Graduate'),
            )

    :attr:`~Field.default`
        El valor por defecto para el campo. Este puede ser un valor o un callable
        objeto. Si es callable será llamado cada vez un nuevo objeto es 
        creado.
	
	<todo this paragraph>
    :attr:`~Field.help_text`
        Extra "help" text to be displayed under the field on the object's admin
        form. It's useful for documentation even if your object doesn't have an
        admin form.

    :attr:`~Field.primary_key`
        Si ``True``, este campo es la llave primaria para el modelo.

        Si tú no especificas :attr:`primary_key=True <Field.primary_key>` en
        ningún campo de tu modelo , Django automáticamente añadirá un
        :class:`IntegerField` <todo: to hold> la llave primaria, asi que no necesitas <todo: set>
        :attr:`primary_key=True <Field.primary_key>` a ninguno de los campos
        al menos que tú quieras modificar el comportamiento por defecto de la llave primaria. Para mas,
        ver :ref:`automatic-primary-key-fields`.

    :attr:`~Field.unique`
        Si ``True``, este campo debe ser único en toda la tabla.

Otra vez, estos son solo descripciones breves de las opciones mas comunes para un campo. Detalles 
completos pueden ser encontrados en la :ref:`referencia común modelo campo opcion
<common-model-field-options>`.

.. _automatic-primary-key-fields:

Campo automático llave primaria
-------------------------------

Por defecto, Django dá a cada modelo el siguiente campo::

    id = models.AutoField(primary_key=True)

Esto es una llave primaria auto-incrementada.

Si tú quisieras especificar un <todo: custom> llave  primaria, solo especifica
:attr:`primary_key=True <Field.primary_key>` a uno de tus campos. Si Django
vee que tú explicitamente <todo: set> :attr:`Field.primary_key`, no añadirá automaticamente
la columna ``id``.

Cada modelo requiere exactamente un campo tener :attr:`primary_key=True
<Field.primary_key>`.

Verbose field names
-------------------

Cada tipo de campo, excepto por :class:`~django.db.models.ForeignKey`,
:class:`~django.db.models.ManyToManyField` y
:class:`~django.db.models.OneToOneField`, toma un primer argumento opcional
posicional -- un nombre verbose. Si el nombre verbose no es dado, Django 
automáticamente lo creará usando el nombre del atributo del campo, convirtiendo <todo: underscores>
a espacios.

En este ejemplo, el nombre verbose es ``"Person's first name"``::

    first_name = models.CharField("Person's first name", max_length=30)

En este ejemplo, el nombre verbose es ``"first name"``::

    first_name = models.CharField(max_length=30)

:class:`~django.db.models.ForeignKey`,
:class:`~django.db.models.ManyToManyField` y
:class:`~django.db.models.OneToOneField` requiere el primer argumento sea un
modelo clase, asi usar el :attr:`~Field.verbose_name` argumento keyword::

    poll = models.ForeignKey(Poll, verbose_name="the related poll")
    sites = models.ManyToManyField(Site, verbose_name="list of sites")
    place = models.OneToOneField(Place, verbose_name="related place")

La convención es no poner mayúscula a la primera letra del 
:attr:`~Field.verbose_name`. Django automáticamente hará mayúscula la primera
letra donde necesita hacerlo.

Relaciones
----------

Claramente, el poder de base de datos relacionales radica en relacionar tablas las unas a
otras. Django ofrece formas de definiir los tres tipos mas comunes de relaciones de 
base de datos: muchos-a-uno, muchos-a-muchos y uno-a-uno.

Relación muchos-a-uno
~~~~~~~~~~~~~~~~~~~~~

Para definir una relación muchos-a-uno, usa :class:`~django.db.models.ForeignKey`.
Utilizalo como cualquier otro tipo de :class:`~django.db.models.Field`:
incluyendolo como un atributo de clase de tu modelo.

:class:`~django.db.models.ForeignKey` requiere un argumento posicional: la clase
al cual el modelo está relacionado.

Por ejemplo, si un modelo ``Car`` tiene un ``Manufacturer`` -- eso es, un
``Manufacturer`` puede hacer multiples carros pero cada ``Car`` solo tine un
``Manufacturer`` -- usa las siguientes definiciones::

    class Manufacturer(models.Model):
        # ...

    class Car(models.Model):
        manufacturer = models.ForeignKey(Manufacturer)
        # ...

También puedes crear :ref:`relaciones recursivas <recursive-relationships>` (un
objeto con una relación de muchos-a-uno al el mismo) y :ref:`y relaciones
a modelos todavía no definidos <lazy-relationships>`; ver :ref:`la referencia
modelo campo <ref-foreignkey>` para mas detalles.

Es sugerido, pero no requerido, que el nombre de un 
:class:`~django.db.models.ForeignKey` campo (``manufacturer`` en el ejemplo de
de arriba) sea el nombre del modelo, en minúscula. Tú puedes, claro, nombrar el campo
lo que tú quieras. Por ejemplo::

    class Car(models.Model):
        company_that_makes_it = models.ForeignKey(Manufacturer)
        # ...

.. vertambién::

    Ver el `ejemplo del modelo relación de Muchos-a-uno`_ para un completo ejemplo.

.. _Ejemplo del modelo relación Muchos-a-uno: http://www.djangoproject.com/documentation/models/many_to_one/

:class:`~django.db.models.ForeignKey` campos también aceptan un número de argumentos
extras los cuales son explicados en :ref:`la referencia modelo campo
<foreign-key-arguments>`. Estas opciones ayudan a definir como la relación debe
funcionar; todas son opcionales.

Relación Muchos-a-muchos
~~~~~~~~~~~~~~~~~~~~~~~~

Para definir una relación de muchos-a-muchos, usa
:class:`~django.db.models.ManyToManyField`. Utilizalo como cualquier otro tipo de
:class:`~django.db.models.Field`: incluyendolo como un atributo de clase de
tu modelo.

:class:`~django.db.models.ManyToManyField` requiere un argumento posicional: la
clase al cual el modelo está relacionado.

Por ejemplo, si una ``Pizza`` tiene múltiples objetos ``Topping`` -- que es, un
``Topping`` puede estar en múltiples pizzas y cada ``Pizza`` tiene múltiples toppings
-- aquí está como tú representarías eso::

    class Topping(models.Model):
        # ...

    class Pizza(models.Model):
        # ...
        toppings = models.ManyToManyField(Topping)

Como en :class:`~django.db.models.ForeignKey`, tu también puedes crear
:ref:`relaciones recursivas <recursive-relationships>` (un objeto con una
relación muchos-a-uno al el mismo) y :ref:`relaciones a modelos todavía no
definidos <lazy-relationships>`; ver :ref:`la referencia modelo campo
<ref-manytomany>` para mas detalles.

Es sugerido, pero no requerido, que el nombre de una
:class:`~django.db.models.ManyToManyField` (``toppings`` en el ejemplo de arriba)
sea plural describiendo el conjunto de modelo objetos relaciones. 

No importa cual modelo tenga la
:class:`~django.db.models.ManyToManyField`, pero tu solo lo necesitas en uno de los
modelos -- no en ambos.

Generalmente, :class:`~django.db.models.ManyToManyField` instancias deberían ir en el
objeto que va ser editado en la interface admin, si tú estás usando  
el admin de Django. En el ejemplo de arriba, ``toppings`` está en ``Pizza`` (en vez que
``Topping`` tenga una ``pizzas`` :class:`~django.db.models.ManyToManyField` )
porque es mas natural pensar acerca de una pizza teniedo toppings que un 
topping estando en múltiples pizzas. La forma como está definida arriba, la ``Pizza`` admin
form dejará a los usuarios seleccionar los toppings.

.. vertambien:: 

    Ver la `Many-to-many relationship model example`_ para un ejemplo completo.
<todo below>
.. _Many-to-many relationship model example: http://www.djangoproject.com/documentation/models/many_to_many/

:class:`~django.db.models.ManyToManyField` campos también acepta un número de argumentos
extras los cuales son explicados en :ref:`la referencia modelo campo
<manytomany-arguments>`. Estas opciones ayudan a definir how la relación deberí
funcionar; todos son opcionales.

.. _intermediary-manytomany:

Extra campos en relación muchos-a-muchos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

Cuando tú estás trabajando solamente con una simple relación muchos-a-muchos tales como
mezclar y emparejar pizzas y toppings, un estandard :class:`~django.db.models.ManyToManyField` es todo lo que tú necesitas. Sin embargo, a veces
tú necesitaras asociar datos con la relación entre los dos modelos.

Por ejemplo, considera el caso de una aplicación <todo: tracking> los grupos musicales
a cuales los músicos pertenecen. Hay una relación de muchos-a-muchos entre una persona
y los grupos de los cuales ellos son miembros, asi que tu puedes usar una 
:class:`~django.db.models.ManyToManyField` para representar esta relación.
Sin embargo, hay muchos detalles acerca de los datos que tu <todo: might want to>
colectar o recoger, tales como la fecha cuando la persona se unió al grupo. 

Para esas situaciones, Django te permite especificar el modelo que será usado
para governar la relacioón muchos-a-muchos. Entonces tu puedes poner campos extras en 
el modelo intermediato. El modelo intermediato es asociado con la  
:class:`~django.db.models.ManyToManyField` usando el 
:attr:`a travez <ManyToManyFields.through>` argumento que a apunta al modelo
que actuará como un intermediario. Para nuestro ejemplo de músicos, el código parecerá
algo asi:

    class Person(models.Model):
        name = models.CharField(max_length=128)

        def __unicode__(self):
            return self.name

    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through='Membership')

        def __unicode__(self):
            return self.name

    class Membership(models.Model):
        person = models.ForeignKey(Person)
        group = models.ForeignKey(Group)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)

Cuando tú defines el modelo intermediario, tú explícitamente especificas <@todo foreign
keys> a los modelos que están involucrados en la relación MuchosAMuchos. Esta
declaración explícita define como los dos modelos están relacionados.

Hay pequeñas restricciones sobre el modelo intermedio:

    * Tu modelo intermedio debe contener uno - y *solo* uno - <@todo foreign key>
      al modelo <@todo target> (esto sería ``Person`` en nuestro ejemplo). Si tu
      tienes mas de un <@todo: foreign key>, un error de validación ocurrirá.
  
    * Tu modelo intermedio debe contener uno - y *solo* uno - <@todo: foreign key> 
      al modelo fuente (esto sería ``Group`` en nuestro ejemplo). If you
      have more than one foreign key, a validation error will be raised.

    * The only exception to this is a model which has a many-to-many
      relationship to itself, through an intermediary model. In this
      case, two foreign keys to the same model are permitted, but they
      will be treated as the two (different) sides of the many-to-many
      relation.
    
    * When defining a many-to-many relationship from a model to
      itself, using an intermediary model, you *must* use
      :attr:`symmetrical=False <ManyToManyFields.symmetrical>` (see 
      :ref:`the model field reference <manytomany-arguments>`).

Now that you have set up your :class:`~django.db.models.ManyToManyField` to use
your intermediary model (``Membership``, in this case), you're ready to start
creating some many-to-many relationships. You do this by creating instances of
the intermediate model::
    
    >>> ringo = Person.objects.create(name="Ringo Starr")
    >>> paul = Person.objects.create(name="Paul McCartney")
    >>> beatles = Group.objects.create(name="The Beatles")
    >>> m1 = Membership(person=ringo, group=beatles,
    ...     date_joined=date(1962, 8, 16), 
    ...     invite_reason= "Needed a new drummer.")
    >>> m1.save()
    >>> beatles.members.all()
    [<Person: Ringo Starr>]
    >>> ringo.group_set.all()
    [<Group: The Beatles>]
    >>> m2 = Membership.objects.create(person=paul, group=beatles,
    ...     date_joined=date(1960, 8, 1), 
    ...     invite_reason= "Wanted to form a band.")
    >>> beatles.members.all()
    [<Person: Ringo Starr>, <Person: Paul McCartney>]

Unlike normal many-to-many fields, you *can't* use ``add``, ``create``,
or assignment (i.e., ``beatles.members = [...]``) to create relationships::

    # THIS WILL NOT WORK
    >>> beatles.members.add(john)
    # NEITHER WILL THIS
    >>> beatles.members.create(name="George Harrison")
    # AND NEITHER WILL THIS
    >>> beatles.members = [john, paul, ringo, george]
    
Porqué? Tú no puedes crear simplemente una relación entre una ``Person`` y un ``Group``
- tú necesitas especificar todos los detalles para la relación requerida por el
modelo ``Membership``. El simple ``add``, ``create`` y llamadas de asignamiento
no proveen una forma de especificar este extra detalle. Como resultado, ellos estan
desabilitados para relaciones muchos-a-muchos que usan un modelo intermediario.
La única forma de crear este tipo de relación es creando instancias del
modelo intermedio.

El método ``remove`` es desabilitado por razones similares. Sin embargo, el
el método ``clear()`` puede ser usado para borrar todas la relaciones muchos-a-muchos
por una instancia::

    # Beatles have broken up
    >>> beatles.members.clear()

Una vez que hayas establecida la relación muchos-a-muchos al crear instancias
de tu modelo intermedio, tu puedes hacer queries. Tal como en una relación
normal de muchos-a-muchos, tu puedes <todo: query> usando los atributos del
modelo muchos-a-muchos-relacionados::

    # Encuentra todos los grupos con un miembro el cual su nombre empieza con 'Paul'
    >>> Groups.objects.filter(members__name__startswith='Paul')
    [<Group: The Beatles>]

Como estás usando un modelo intermedio, tú también pudedes hacer queries sobre sus atributos::

    # Encuentra todos los miembros de los Beatles que se unieron después de 1 Enero 1961
    >>> Person.objects.filter(
    ...     group__name='The Beatles',
    ...     membership__date_joined__gt=date(1961,1,1))
    [<Person: Ringo Starr]
    

Rrelaciones Uno-a-Uno 
~~~~~~~~~~~~~~~~~~~~~

Para definir una relación uno-a-uno, usa
:class:`~django.db.models.OneToOneField`. Tú lo utilizas tal como si fuera cualquier otro
tipo de ``Campo``: al incluirlo como un atributo clase de tu modelo.

Este es mas <todo: useful> en la llave primaria de un objeto cuando ese objeto "extiende"
otro objeto de alguna forma.

:class:`~django.db.models.OneToOneField` requiere un argumento posicional: la
clase al cual el modelo está relacionado.

Por ejemplo, si tú estás construyendo un base de datos de "lugares", tu podrías
construir <todo: pretty> estandares <todo: stuff> tales como dirección, número de teléfono, etc. en la
base de datos. Entonces, si tú quisieras construir una base de datos de restaurantes encima
de los lugares, en vez de <todo: repeating yourself> y replicando esos
campos en el modelo ``Restaurante``, tu puedes hacer ``Restaurante`` tener 
un :class:`~django.db.models.OneToOneField` a ``Lugar`` (porque un
restaurante "es un" lugar; de hecho, <todo: to handle> esto tú tipicamente usarías
:ref:`inheritance <model-inheritance>`, el cual invuelve una implícita
relación uno-a-uno).

Como con :class:`~django.db.models.ForeignKey`, una
:ref:`relación recursiva <recursive-relationships>`
puede ser definida y
:ref:`<todo references to as-yet undefined models> <lazy-relationships>`
puede ser hecha; ver :ref:`the model field reference <ref-onetoone>` para detalles.

.. seealso::

    Ver el `ejemplo de un modelo relación Uno-a-uno`_ para un completo ejemplo.

.. _One-to-one relationship model example: http://www.djangoproject.com/documentation/models/one_to_one/

.. versionadded:: 1.0

:class:`~django.db.models.OneToOneField` campos también aceptan un argumento opcional
descriro en el :ref:`referencia modelo campo <ref-onetoone>`.

:class:`~django.db.models.OneToOneField` clases usadas para automáticamente convertirse
en la llave primaria del modelo. Esto ya no es verdad (aunque tu puedes pasarlo
manualmente en el :attr:`~django.db.models.Field.primary_key` argumento si tu quieres).

<todo: Thus>, es posible ahora tener multiplos campos de tipo
:class:`~django.db.models.OneToOneField` en un solo modelo.

Modelos across files
-------------------

Es perfectamente OK relacionar un modelo a uno desde otro app. Para hacer esto,
importa el modelo relacionado al inicio/principio del modelo que <todo: holds> tu modelo. Entonces,
solo refiere al otro modelo clase cuando lo necesites. Por ejemplo::

    from mysite.geography.models import ZipCode

    class Restaurant(models.Model):
        # ...
        zip_code = models.ForeignKey(ZipCode)

Restricciones nombre de  campo
------------------------------

Django pone solo dos restricciones sobre los nombres del los campos de un modelo:

    1. Un nombre de campo no puede ser una palabra reservada de Python, porque eseo resultaría
       en un error de syntaxis en Python. Por ejemplo::

           class Example(models.Model):
               pass = models.IntegerField() # 'pass' es una palabra reservada!

    2. Un nombre de campo no puede contener mas de un <todo: underscore> en una fila, debido a
       la forma como la sintaxis de Django <todo: query lookup> funciona. Por ejemplo::

           class Example(models.Model):
               foo__bar = models.IntegerField() # 'foo__bar' tiene dos underscores!

Estas limitaciones puden ser solucionadas de otra forma, though, porque tu nombre de campo no 
necesariamente tiene que ser igual al nombre de columna de tu base de datos. Ver la 
:attr:`~Field.db_column` opción.

Palabras reservadas de SQL, tales como ``join``, ``where`` or ``select``, *están* permitidas como
nombres de campos del modelo, porque Django escapa todos los nombres de tablas y columnas de las base de datos
en cada <todo: underlying SQL query>. Usa la <todo: quoting syntax> de tu
<todo: particular database engine.>

Especiales(Custom) Tipos de campo
---------------------------------

.. versionadded:: 1.0

Si alguno de los <todo: model fields> existentes no puede ser usado 

If one of the existing model fields cannot be used to fit your purposes, or if
you wish to take advantage of some less common database column types, you can
create your own field class. Full coverage of creating your own fields is
provided in :ref:`howto-custom-model-fields`.

.. _meta-options:

Meta options
============

Give your model metadata by using an inner ``class Meta``, like so::

    class Ox(models.Model):
        horn_length = models.IntegerField()

        class Meta:
            ordering = ["horn_length"]
            verbose_name_plural = "oxen"

Model metadata is "anything that's not a field", such as ordering options
(:attr:`~Options.ordering`), database table name (:attr:`~Options.db_table`), or
human-readable singular and plural names (:attr:`~Options.verbose_name` and
:attr:`~Options.verbose_name_plural`). None are required, and adding ``class
Meta`` to a model is completely optional.

A complete list of all possible ``Meta`` options can be found in the :ref:`model
option reference <ref-models-options>`.

.. _model-methods:

Model methods
=============

Define custom methods on a model to add custom "row-level" functionality to your
objects. Whereas :class:`~django.db.models.Manager` methods are intended to do
"table-wide" things, model methods should act on a particular model instance.

This is a valuable technique for keeping business logic in one place -- the
model.

For example, this model has a few custom methods::

    from django.contrib.localflavor.us.models import USStateField

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        birth_date = models.DateField()
        address = models.CharField(max_length=100)
        city = models.CharField(max_length=50)
        state = USStateField() # Yes, this is America-centric...

        def baby_boomer_status(self):
            "Returns the person's baby-boomer status."
            import datetime
            if datetime.date(1945, 8, 1) <= self.birth_date <= datetime.date(1964, 12, 31):
                return "Baby boomer"
            if self.birth_date < datetime.date(1945, 8, 1):
                return "Pre-boomer"
            return "Post-boomer"

        def is_midwestern(self):
            "Returns True if this person is from the Midwest."
            return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

        def _get_full_name(self):
            "Returns the person's full name."
            return '%s %s' % (self.first_name, self.last_name)
        full_name = property(_get_full_name)

The last method in this example is a :term:`property`. `Read more about
properties`_.

.. _Read more about properties: http://www.python.org/download/releases/2.2/descrintro/#property

The :ref:`model instance reference <ref-models-instances>` has a complete list
of :ref:`methods automatically given to each model <model-instance-methods>`.
You can override most of these -- see `overriding predefined model methods`_,
below -- but there are a couple that you'll almost always want to define:

    :meth:`~Model.__unicode__`
        A Python "magic method" that returns a unicode "representation" of any
        object. This is what Python and Django will use whenever a model
        instance needs to be coerced and displayed as a plain string. Most
        notably, this happens when you display an object in an interactive
        console or in the admin.
        
        You'll always want to define this method; the default isn't very helpful
        at all.
        
    :meth:`~Model.get_absolute_url`
        This tells Django how to calculate the URL for an object. Django uses
        this in its admin interface, and any time it needs to figure out a URL
        for an object.
        
        Any object that has a URL that uniquely identifies it should define this
        method.

Overriding predefined model methods
-----------------------------------

There's another set of :ref:`model methods <model-instance-methods>` that
encapsulate a bunch of database behavior that you'll want to customize. In
particular you'll often want to change the way :meth:`~Model.save` and
:meth:`~Model.delete` work.

You're free to override these methods (and any other model method) to alter
behavior.

A classic use-case for overriding the built-in methods is if you want something
to happen whenever you save an object. For example (see
:meth:`~Model.save` for documentation of the parameters it accepts)::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            do_something()
            super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.
            do_something_else()

You can also prevent saving::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            if self.name == "Yoko Ono's blog":
                return # Yoko shall never have her own blog!
            else:
                super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.

It's important to remember to call the superclass method -- that's that
``super(Blog, self).save()`` business -- to ensure that the object still gets
saved into the database. If you forget to call the superclass method, the
default behavior won't happen and the database won't get touched.

Executing custom SQL
--------------------

Another common pattern is writing custom SQL statements in model methods and
module-level methods. The object :class:`django.db.connection
<django.db.backends.DatabaseWrapper>` represents the current database
connection. To use it, call :meth:`connection.cursor()
<django.db.backends.DatabaseWrapper.cursor>` to get a cursor object. Then, call
``cursor.execute(sql, [params])`` to execute the SQL and
:meth:`cursor.fetchone() <django.db.backends.CursorWrapper.fetchone>` or
:meth:`cursor.fetchall() <django.db.backends.CursorWrapper.fetchall>` to return
the resulting rows. For example::

    def my_custom_sql(self):
        from django.db import connection
        cursor = connection.cursor()
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()
        return row

:class:`connection <django.db.backends.DatabaseWrapper>` and :class:`cursor
<django.db.backends.CursorWrapper>` mostly implement the standard Python
DB-API -- see :pep:`249` -- with the addition of Django's :ref:`transaction
handling <topics-db-transactions>`. If you're not familiar with the Python
DB-API, note that the SQL statement in :meth:`cursor.execute()
<django.db.backends.CursorWrapper.execute>` uses placeholders, ``"%s"``, rather
than adding parameters directly within the SQL. If you use this technique, the
underlying database library will automatically add quotes and escaping to your
parameter(s) as necessary. (Also note that Django expects the ``"%s"``
placeholder, *not* the ``"?"`` placeholder, which is used by the SQLite Python
bindings. This is for the sake of consistency and sanity.)

A final note: If all you want to do is a custom ``WHERE`` clause, you can use
the :meth:`~QuerySet.extra` lookup method, which lets you add custom SQL to a
query.

.. _model-inheritance:

Model inheritance
=================

.. versionadded:: 1.0

Model inheritance in Django works almost identically to the way normal
class inheritance works in Python. The only decision you have to make
is whether you want the parent models to be models in their own right
(with their own database tables), or if the parents are just holders
of common information that will only be visible through the child
models.

Often, you will just want to use the parent class to hold information
that you don't want to have to type out for each child model. This
class isn't going to ever be used in isolation, so
:ref:`abstract-base-classes` are what you're after. However, if you're
subclassing an existing model (perhaps something from another
application entirely), or want each model to have its own database
table, :ref:`multi-table-inheritance` is the way to go.

.. _abstract-base-classes:

Abstract base classes
---------------------

Abstract base classes are useful when you want to put some common
information into a number of other models. You write your base class
and put ``abstract=True`` in the :ref:`Meta <meta-options>`
class. This model will then not be used to create any database
table. Instead, when it is used as a base class for other models, its
fields will be added to those of the child class. It is an error to
have fields in the abstract base class with the same name as those in
the child (and Django will raise an exception).

An example::

    class CommonInfo(models.Model):
        name = models.CharField(max_length=100)
        age = models.PositiveIntegerField()

        class Meta:
            abstract = True

    class Student(CommonInfo):
        home_group = models.CharField(max_length=5)

The ``Student`` model will have three fields: ``name``, ``age`` and
``home_group``. The ``CommonInfo`` model cannot be used as a normal Django
model, since it is an abstract base class. It does not generate a database
table or have a manager, and cannot be instantiated or saved directly.

For many uses, this type of model inheritance will be exactly what you want.
It provides a way to factor out common information at the Python level, whilst
still only creating one database table per child model at the database level.

``Meta`` inheritance
~~~~~~~~~~~~~~~~~~~~

When an abstract base class is created, Django makes any :ref:`Meta <meta-options>`
inner class you declared in the base class available as an
attribute. If a child class does not declare its own :ref:`Meta <meta-options>`
class, it will inherit the parent's :ref:`Meta <meta-options>`. If the child wants to
extend the parent's :ref:`Meta <meta-options>` class, it can subclass it. For example::

    class CommonInfo(models.Model):
        ...
        class Meta:
            abstract = True
            ordering = ['name']

    class Student(CommonInfo):
        ...
        class Meta(CommonInfo.Meta):
            db_table = 'student_info'

Django does make one adjustment to the :ref:`Meta <meta-options>` class of an abstract base
class: before installing the :ref:`Meta <meta-options>` attribute, it sets ``abstract=False``.
This means that children of abstract base classes don't automatically become
abstract classes themselves. Of course, you can make an abstract base class
that inherits from another abstract base class. You just need to remember to
explicitly set ``abstract=True`` each time.

Some attributes won't make sense to include in the :ref:`Meta <meta-options>` class of an
abstract base class. For example, including ``db_table`` would mean that all
the child classes (the ones that don't specify their own :ref:`Meta <meta-options>`) would use
the same database table, which is almost certainly not what you want.

.. _abstract-related-name:

Be careful with ``related_name``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you are using the :attr:`~django.db.models.ForeignKey.related_name` attribute on a ``ForeignKey`` or
``ManyToManyField``, you must always specify a *unique* reverse name for the
field. This would normally cause a problem in abstract base classes, since the
fields on this class are included into each of the child classes, with exactly
the same values for the attributes (including :attr:`~django.db.models.ForeignKey.related_name`) each time.

To work around this problem, when you are using :attr:`~django.db.models.ForeignKey.related_name` in an
abstract base class (only), part of the name should be the string
``'%(class)s'``. This is replaced by the lower-cased name of the child class
that the field is used in. Since each class has a different name, each related
name will end up being different. For example::

    class Base(models.Model):
        m2m = models.ManyToMany(OtherModel, related_name="%(class)s_related")

        class Meta:
            abstract = True

    class ChildA(Base):
        pass

    class ChildB(Base):
        pass

The reverse name of the ``ChildA.m2m`` field will be ``childa_related``,
whilst the reverse name of the ``ChildB.m2m`` field will be
``childb_related``. It is up to you how you use the ``'%(class)s'`` portion to
construct your related name, but if you forget to use it, Django will raise
errors when you validate your models (or run :djadmin:`syncdb`).

If you don't specify a :attr:`~django.db.models.ForeignKey.related_name` attribute for a field in an
abstract base class, the default reverse name will be the name of the
child class followed by ``'_set'``, just as it normally would be if
you'd declared the field directly on the child class. For example, in
the above code, if the :attr:`~django.db.models.ForeignKey.related_name` attribute was omitted, the
reverse name for the ``m2m`` field would be ``childa_set`` in the
``ChildA`` case and ``childb_set`` for the ``ChildB`` field.

.. _multi-table-inheritance:

Multi-table inheritance
-----------------------

The second type of model inheritance supported by Django is when each model in
the hierarchy is a model all by itself. Each model corresponds to its own
database table and can be queried and created individually. The inheritance
relationship introduces links between the child model and each of its parents
(via an automatically-created :class:`~django.db.models.fields.OneToOneField`).
For example::

    class Place(models.Model):
        name = models.CharField(max_length=50)
        address = models.CharField(max_length=80)

    class Restaurant(Place):
        serves_hot_dogs = models.BooleanField()
        serves_pizza = models.BooleanField()

All of the fields of ``Place`` will also be available in ``Restaurant``,
although the data will reside in a different database table. So these are both
possible::

    >>> Place.objects.filter(name="Bob's Cafe")
    >>> Restaurant.objects.filter(name="Bob's Cafe")

If you have a ``Place`` that is also a ``Restaurant``, you can get from the
``Place`` object to the ``Restaurant`` object by using the lower-case version
of the model name::

    >>> p = Place.objects.filter(name="Bob's Cafe")
    # If Bob's Cafe is a Restaurant object, this will give the child class:
    >>> p.restaurant
    <Restaurant: ...>

However, if ``p`` in the above example was *not* a ``Restaurant`` (it had been
created directly as a ``Place`` object or was the parent of some other class),
referring to ``p.restaurant`` would give an error.

``Meta`` and multi-table inheritance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the multi-table inheritance situation, it doesn't make sense for a child
class to inherit from its parent's :ref:`Meta <meta-options>` class. All the :ref:`Meta <meta-options>` options
have already been applied to the parent class and applying them again would
normally only lead to contradictory behaviour (this is in contrast with the
abstract base class case, where the base class doesn't exist in its own
right).

So a child model does not have access to its parent's :ref:`Meta <meta-options>` class. However,
there are a few limited cases where the child inherits behaviour from the
parent: if the child does not specify an :attr:`django.db.models.Options.ordering` attribute or a
:attr:`django.db.models.Options.get_latest_by` attribute, it will inherit these from its parent.

If the parent has an ordering and you don't want the child to have any natural
ordering, you can explicitly disable it::

    class ChildModel(ParentModel):
        ...
        class Meta:
            # Remove parent's ordering effect
            ordering = []

Inheritance and reverse relations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because multi-table inheritance uses an implicit
:class:`~django.db.models.fields.OneToOneField` to link the child and
the parent, it's possible to move from the parent down to the child,
as in the above example. However, this uses up the name that is the
default :attr:`~django.db.models.ForeignKey.related_name` value for
:class:`django.db.models.fields.ForeignKey` and
:class:`django.db.models.fields.ManyToManyField` relations.  If you
are putting those types of relations on a subclass of another model,
you **must** specify the
:attr:`~django.db.models.ForeignKey.related_name` attribute on each
such field. If you forget, Django will raise an error when you run
:djadmin:`validate` or :djadmin:`syncdb`.

For example, using the above ``Place`` class again, let's create another
subclass with a :class:`~django.db.models.fields.ManyToManyField`::

    class Supplier(Place):
        # Must specify related_name on all relations.
        customers = models.ManyToManyField(Restaurant, related_name='provider')


Specifying the parent link field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As mentioned, Django will automatically create a
:class:`~django.db.models.fields.OneToOneField` linking your child
class back any non-abstract parent models. If you want to control the
name of the attribute linking back to the parent, you can create your
own :class:`~django.db.models.fields.OneToOneField` and set
:attr:`parent_link=True <django.db.models.fields.OneToOneField.parent_link>` 
to indicate that your field is the link back to the parent class.

Multiple inheritance
--------------------

Just as with Python's subclassing, it's possible for a Django model to inherit
from multiple parent models. Keep in mind that normal Python name resolution
rules apply. The first base class that a particular name (e.g. :ref:`Meta
<meta-options>`) appears in will be the one that is used; for example, this
means that if multiple parents contain a :ref:`Meta <meta-options>` class,
only the first one is going to be used, and all others will be ignored.

Generally, you won't need to inherit from multiple parents. The main use-case
where this is useful is for "mix-in" classes: adding a particular extra
field or method to every class that inherits the mix-in. Try to keep your
inheritance hierarchies as simple and straightforward as possible so that you
won't have to struggle to work out where a particular piece of information is
coming from.
